#****************************************************************************************************************************************
                                          学习和工作笔记，或许某一天会再来看
#****************************************************************************************************************************************

一、目录介绍:  script/  编译和执行脚本目录
               src/     源代码目录
               config.xml 应用配置文件
               pom.xml  使用maven构建时配置文件

二、详细介绍:
    ① pom.xml  使用maven构建java或scala时需要的配置文件，具体使用哪种构建工具构建java或scala看个人习惯。对了sbt和maven是同等级别的
               构建工具，而且sbt是使用的maven仓库，所以他俩细细追究起来差不多，看个人习惯。maven的常用命令
               : mvn archetype:generate 自动生成一个规范框架的项目，里面同样自动生成pom.xml,所以在开始一个项目前这是很好的自动布置目录方式
               ：mvn compile 编译java程序
               : mvn package 打包java程序
               : mvn dependency:tree 这一个是展示整个项目的依赖包树，非常有用。例如：导入两个不同的包(但是这两个包依赖同一个包),这样就会
                                     出现重复包含，不要担心，maven会自动包含那个嵌套最浅的依赖，这样就只导入一个。问题来了这两个包依赖的
                                     同一个包的版本不一样，运行时就会报错，通过这个命令查看，并手动修改导入包的pom.xml，解决异常

    ②config.xml xml形式的应用配置

    ③ src/ 发邮件逻辑采用的是从kafka接受消息，然后利用线程池发送。具体如下：

         首先：创建一些发邮件句柄，以供线程池发邮件使用。
         然后：根据kafka上指定topic的分区数，建立相等数量的消息流，因为一个分区只能被一个消费者食用，所以当消息流多时就会有消息流闲置，
               当消息流少时，就会有消息流同时消费几个分区。
         最后：将消息流句柄和邮件句柄提供给线程中的任务使用。

         当消息流创建后，它会与kafka保持连接，通过在任务中循环检测是否流中含有数据来消费数据，没数据时就阻塞，所以一个任务可以长久保持
         ，除非异常才会退出。这样可以产生一个好处，有利于主线程的监控。原因：由于一个任务保持有一个消息流(而且同一个应用中不允许多次
         创建消息流)，只要没异常就不会退出，而线程池有shutdown()和awaitTermination()两个接口，作用为调用后阻止新任务的提交，但是会等待
         已经提交的任务完成才会关闭线程池，这样只有长久保持的任务由于异常一个个返回时，整个应用才会结束，这样感觉挺符合直观逻辑的。当然
         在任务中添加了许多处理异常逻辑，保证它不会轻易结束。


   遗留问题：由于一个应用中当多次生成消息流时会触发异常，所以应用中没有实现恢复消息流的逻辑，等有时间阅读源码后再修改
    
    
